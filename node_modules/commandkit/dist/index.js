"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  CommandKit: () => CommandKit,
  CommandType: () => CommandType,
  ReloadType: () => ReloadType
});
module.exports = __toCommonJS(src_exports);

// src/utils/get-paths.ts
var import_path = __toESM(require("path"));
var import_fs = __toESM(require("fs"));
function getFilePaths(directory, nesting) {
  let filePaths = [];
  if (!directory)
    return filePaths;
  const files = import_fs.default.readdirSync(directory, { withFileTypes: true });
  for (const file of files) {
    const filePath = import_path.default.join(directory, file.name);
    if (file.isFile()) {
      filePaths.push(filePath);
    }
    if (nesting && file.isDirectory()) {
      filePaths = [...filePaths, ...getFilePaths(filePath, true)];
    }
  }
  return filePaths;
}
function getFolderPaths(directory, nesting) {
  let folderPaths = [];
  if (!directory)
    return folderPaths;
  const folders = import_fs.default.readdirSync(directory, { withFileTypes: true });
  for (const folder of folders) {
    const folderPath = import_path.default.join(directory, folder.name);
    if (folder.isDirectory()) {
      folderPaths.push(folderPath);
      if (nesting) {
        folderPaths = [...folderPaths, ...getFolderPaths(folderPath, true)];
      }
    }
  }
  return folderPaths;
}

// src/utils/resolve-file-url.ts
var import_path2 = __toESM(require("path"));
function toFileURL(filePath) {
  const resolvedPath = import_path2.default.resolve(filePath);
  return "file://" + resolvedPath.replace(/\\\\|\\/g, "/");
}

// src/utils/colors.ts
var resetColor = "\x1B[0m";
var colors_default = {
  reset: (text) => `${text}${resetColor}`,
  bright: (text) => `\x1B[1m${text}${resetColor}`,
  dim: (text) => `\x1B[2m${text}${resetColor}`,
  underscore: (text) => `\x1B[4m${text}${resetColor}`,
  blink: (text) => `\x1B[5m${text}${resetColor}`,
  reverse: (text) => `\x1B[7m${text}${resetColor}`,
  hidden: (text) => `\x1B[8m${text}${resetColor}`,
  black: (text) => `\x1B[30m${text}${resetColor}`,
  red: (text) => `\x1B[31m${text}${resetColor}`,
  green: (text) => `\x1B[32m${text}${resetColor}`,
  yellow: (text) => `\x1B[33m${text}${resetColor}`,
  blue: (text) => `\x1B[34m${text}${resetColor}`,
  magenta: (text) => `\x1B[35m${text}${resetColor}`,
  cyan: (text) => `\x1B[36m${text}${resetColor}`,
  white: (text) => `\x1B[37m${text}${resetColor}`,
  bgBlack: (text) => `\x1B[40m${text}${resetColor}`,
  bgRed: (text) => `\x1B[41m${text}${resetColor}`,
  bgGreen: (text) => `\x1B[42m${text}${resetColor}`,
  bgYellow: (text) => `\x1B[43m${text}${resetColor}`,
  bgBlue: (text) => `\x1B[44m${text}${resetColor}`,
  bgMagenta: (text) => `\x1B[45m${text}${resetColor}`,
  bgCyan: (text) => `\x1B[46m${text}${resetColor}`,
  bgWhite: (text) => `\x1B[47m${text}${resetColor}`
};

// src/handlers/command-handler/functions/loadCommandsWithRest.ts
async function loadCommandsWithRest(props) {
  if (props.reloading) {
    if (props.client.isReady()) {
      await handleLoading(
        props.client,
        props.commands,
        props.devGuildIds,
        props.reloading,
        props.type
      );
    } else {
      throw new Error(colors_default.red(`\u274C Cannot reload commands when client is not ready.`));
    }
  } else {
    props.client.once("ready", async (c) => {
      await handleLoading(c, props.commands, props.devGuildIds, props.reloading, props.type);
    });
  }
}
async function handleLoading(client, commands, devGuildIds, reloading, type) {
  commands = commands.filter((cmd) => !cmd.options?.deleted);
  const devOnlyCommands = commands.filter((cmd) => cmd.options?.devOnly);
  const globalCommands = commands.filter((cmd) => !cmd.options?.devOnly);
  if (type === "dev") {
    await loadDevCommands(client, devOnlyCommands, devGuildIds, reloading);
  } else if (type === "global") {
    await loadGlobalCommands(client, globalCommands, reloading);
  } else {
    await loadDevCommands(client, devOnlyCommands, devGuildIds, reloading);
    await loadGlobalCommands(client, globalCommands, reloading);
  }
}
async function loadGlobalCommands(client, commands, reloading) {
  const requestBody = commands.map((cmd) => cmd.data);
  await client.application.commands.set(requestBody).catch((error) => {
    console.log(
      colors_default.red(
        `\u274C Error ${reloading ? "reloading" : "loading"} global application commands.
`
      )
    );
    throw new Error(error);
  });
  console.log(
    colors_default.green(
      `\u2705 ${reloading ? "Reloaded" : "Loaded"} ${requestBody.length} global commands.`
    )
  );
}
async function loadDevCommands(client, commands, guildIds, reloading) {
  const requestBody = commands.map((cmd) => cmd.data);
  for (const guildId of guildIds) {
    const targetGuild = client.guilds.cache.get(guildId) || await client.guilds.fetch(guildId);
    if (!targetGuild) {
      console.log(
        `Couldn't ${reloading ? "reloading" : "loading"} commands in guild "${targetGuild}" - guild doesn't exist or client isn't part of the guild.`
      );
      continue;
    }
    await targetGuild.commands.set(requestBody).catch((error) => {
      console.log(
        colors_default.red(
          `\u274C Error ${reloading ? "reloading" : "loading"} developer application commands in guild "${targetGuild?.name || guildId}".
`
        )
      );
      throw new Error(error);
    });
    console.log(
      colors_default.green(
        `\u2705 ${reloading ? "Reloaded" : "Loaded"} ${requestBody.length} developer commands in guild "${targetGuild.name}".`
      )
    );
  }
}

// src/handlers/command-handler/utils/areSlashCommandsDifferent.ts
function areSlashCommandsDifferent(appCommand, localCommand) {
  if (!appCommand.options)
    appCommand.options = [];
  if (!localCommand.options)
    localCommand.options = [];
  if (!appCommand.description)
    appCommand.description = "";
  if (!localCommand.description)
    localCommand.description = "";
  if (localCommand.description !== appCommand.description || localCommand.options.length !== appCommand.options.length) {
    return true;
  }
}

// src/handlers/command-handler/functions/registerCommands.ts
async function registerCommands(props) {
  if (props.reloading) {
    if (props.client.isReady()) {
      await handleRegistration(props.client, props.commands, props.devGuildIds, props.type);
    } else {
      throw new Error(colors_default.red(`\u274C Cannot reload commands when client is not ready.`));
    }
  } else {
    props.client.once("ready", async (c) => {
      await handleRegistration(c, props.commands, props.devGuildIds, props.type);
    });
  }
}
async function handleRegistration(client, commands, devGuildIds, type) {
  const devOnlyCommands = commands.filter((cmd) => cmd.options?.devOnly);
  const globalCommands = commands.filter((cmd) => !cmd.options?.devOnly);
  if (type === "dev") {
    await registerDevCommands(client, devOnlyCommands, devGuildIds);
  } else if (type === "global") {
    await registerGlobalCommands(client, globalCommands);
  } else {
    await registerDevCommands(client, devOnlyCommands, devGuildIds);
    await registerGlobalCommands(client, globalCommands);
  }
}
async function registerGlobalCommands(client, commands) {
  const appCommandsManager = client.application.commands;
  await appCommandsManager.fetch();
  for (const command of commands) {
    const targetCommand = appCommandsManager.cache.find(
      (cmd) => cmd.name === command.data.name
    );
    if (command.options?.deleted) {
      if (!targetCommand) {
        console.log(
          colors_default.yellow(
            `\u23E9 Ignoring: Command "${command.data.name}" is globally marked as deleted.`
          )
        );
      } else {
        await targetCommand.delete().catch((error) => {
          console.log(
            colors_default.red(`\u274C Failed to delete command "${command.data.name}" globally.`)
          );
          console.error(error);
        });
        console.log(colors_default.green(`\u{1F6AE} Deleted command "${command.data.name}" globally.`));
      }
      continue;
    }
    if (targetCommand) {
      const commandsAreDifferent = areSlashCommandsDifferent(targetCommand, command.data);
      if (commandsAreDifferent) {
        await targetCommand.edit(command.data).catch((error) => {
          console.log(
            colors_default.red(
              `\u274C Failed to edit command "${command.data.name}" globally.`
            )
          );
          console.error(error);
        });
        console.log(colors_default.green(`\u2705 Edited command "${command.data.name}" globally.`));
        continue;
      }
    }
    if (targetCommand)
      continue;
    await appCommandsManager.create(command.data).catch((error) => {
      console.log(
        colors_default.red(`\u274C Failed to register command "${command.data.name}" globally.`)
      );
      console.error(error);
    });
    console.log(colors_default.green(`\u2705 Registered command "${command.data.name}" globally.`));
  }
}
async function registerDevCommands(client, commands, guildIds) {
  const devGuilds = [];
  for (const guildId of guildIds) {
    const guild = client.guilds.cache.get(guildId) || await client.guilds.fetch(guildId);
    if (!guild) {
      console.log(
        colors_default.yellow(
          `\u23E9 Ignoring: Guild ${guildId} does not exist or client isn't in this guild.`
        )
      );
      continue;
    }
    devGuilds.push(guild);
  }
  const guildCommandsManagers = [];
  for (const guild of devGuilds) {
    const guildCommandsManager = guild.commands;
    await guildCommandsManager.fetch();
    guildCommandsManagers.push(guildCommandsManager);
  }
  for (const command of commands) {
    for (const guildCommands of guildCommandsManagers) {
      const targetCommand = guildCommands.cache.find((cmd) => cmd.name === command.data.name);
      if (command.options?.deleted) {
        if (!targetCommand) {
          console.log(
            colors_default.yellow(
              `\u23E9 Ignoring: Command "${command.data.name}" is marked as deleted for ${guildCommands.guild.name}.`
            )
          );
        } else {
          await targetCommand.delete().catch((error) => {
            console.log(
              colors_default.red(
                `\u274C Failed to delete command "${command.data.name}" in ${guildCommands.guild.name}.`
              )
            );
            console.error(error);
          });
          console.log(
            colors_default.green(
              `\u{1F6AE} Deleted command "${command.data.name}" in ${guildCommands.guild.name}.`
            )
          );
        }
        continue;
      }
      if (targetCommand) {
        const commandsAreDifferent = areSlashCommandsDifferent(targetCommand, command.data);
        if (commandsAreDifferent) {
          await targetCommand.edit(command.data).catch((error) => {
            console.log(
              colors_default.red(
                `\u274C Failed to edit command "${command.data.name}" in ${guildCommands.guild.name}.`
              )
            );
            console.error(error);
          });
          console.log(
            colors_default.green(
              `\u2705 Edited command "${command.data.name}" in ${guildCommands.guild.name}.`
            )
          );
          continue;
        }
      }
      if (targetCommand)
        continue;
      await guildCommands.create(command.data).catch((error) => {
        console.log(
          colors_default.red(
            `\u274C Failed to register command "${command.data.name}" in ${guildCommands.guild.name}.`
          )
        );
        console.error(error);
      });
      console.log(
        colors_default.green(
          `\u2705 Registered command "${command.data.name}" in ${guildCommands.guild.name}.`
        )
      );
    }
  }
}

// src/handlers/command-handler/validations/botPermissions.ts
function botPermissions_default({ interaction, targetCommand }) {
  const botMember = interaction.guild?.members.me;
  let commandPermissions = targetCommand.options?.botPermissions;
  if (!botMember || !commandPermissions)
    return;
  if (!Array.isArray(commandPermissions)) {
    commandPermissions = [commandPermissions];
  }
  const missingPermissions = [];
  for (const permission of commandPermissions) {
    const hasPermission = botMember.permissions.has(permission);
    if (!hasPermission) {
      missingPermissions.push(`\`${permission.toString()}\``);
    }
  }
  if (missingPermissions.length) {
    interaction.reply({
      content: `\u274C I do not have enough permissions to execute this command. Missing: ${missingPermissions.join(
        ", "
      )}`,
      ephemeral: true
    });
    return true;
  }
}

// src/handlers/command-handler/validations/devOnly.ts
function devOnly_default({ interaction, targetCommand, handlerData }) {
  if (targetCommand.options?.devOnly) {
    if (interaction.inGuild() && !handlerData.devGuildIds.includes(interaction.guildId)) {
      interaction.reply({
        content: "\u274C This command can only be used inside development servers.",
        ephemeral: true
      });
      return true;
    }
    const guildMember = interaction.guild?.members.cache.get(interaction.user.id);
    const memberRoles = guildMember?.roles.cache;
    let hasDevRole = false;
    memberRoles?.forEach((role) => {
      if (handlerData.devRoleIds.includes(role.id)) {
        hasDevRole = true;
      }
    });
    const isDevUser = handlerData.devUserIds.includes(interaction.user.id) || hasDevRole;
    if (!isDevUser) {
      interaction.reply({
        content: "\u274C This command can only be used by developers.",
        ephemeral: true
      });
      return true;
    }
  }
}

// src/handlers/command-handler/validations/guildOnly.ts
function guildOnly_default({ interaction, targetCommand }) {
  if (targetCommand.options?.guildOnly && !interaction.inGuild()) {
    interaction.reply({
      content: "\u274C This command can only be used inside a server.",
      ephemeral: true
    });
    return true;
  }
}

// src/handlers/command-handler/validations/userPermissions.ts
function userPermissions_default({ interaction, targetCommand }) {
  const memberPermissions = interaction.memberPermissions;
  let commandPermissions = targetCommand.options?.userPermissions;
  if (!memberPermissions || !commandPermissions)
    return;
  if (!Array.isArray(commandPermissions)) {
    commandPermissions = [commandPermissions];
  }
  const missingPermissions = [];
  for (const permission of commandPermissions) {
    const hasPermission = memberPermissions.has(permission);
    if (!hasPermission) {
      missingPermissions.push(`\`${permission.toString()}\``);
    }
  }
  if (missingPermissions.length) {
    interaction.reply({
      content: `\u274C You do not have enough permissions to run this command. Missing: ${missingPermissions.join(
        ", "
      )}`,
      ephemeral: true
    });
    return true;
  }
}

// src/handlers/command-handler/validations/index.ts
var validations_default = [botPermissions_default, devOnly_default, guildOnly_default, userPermissions_default];

// src/handlers/command-handler/CommandHandler.ts
var import_rfdc = __toESM(require("rfdc"));
var clone = (0, import_rfdc.default)();
var CommandHandler = class {
  #data;
  constructor({ ...options }) {
    this.#data = {
      ...options,
      builtInValidations: [],
      commands: []
    };
  }
  async init() {
    await this.#buildCommands();
    this.#buildValidations();
    const devOnlyCommands = this.#data.commands.filter((cmd) => cmd.options?.devOnly);
    if (devOnlyCommands.length && !this.#data.devGuildIds.length) {
      console.log(
        colors_default.yellow(
          '\u2139\uFE0F Warning: You have commands marked as "devOnly" but "devGuildIds" has not been set.'
        )
      );
    }
    if (devOnlyCommands.length && !this.#data.devUserIds.length && !this.#data.devRoleIds.length) {
      console.log(
        colors_default.yellow(
          '\u2139\uFE0F Warning: You have commands marked as "devOnly" but not "devUserIds" or "devRoleIds" were set.'
        )
      );
    }
    if (this.#data.bulkRegister) {
      await loadCommandsWithRest({
        client: this.#data.client,
        devGuildIds: this.#data.devGuildIds,
        commands: this.#data.commands
      });
    } else {
      await registerCommands({
        client: this.#data.client,
        devGuildIds: this.#data.devGuildIds,
        commands: this.#data.commands
      });
    }
    this.handleCommands();
  }
  async #buildCommands() {
    const allowedExtensions = /\.(js|mjs|cjs|ts)$/i;
    const commandFilePaths = getFilePaths(this.#data.commandsPath, true).filter(
      (path3) => allowedExtensions.test(path3)
    );
    for (const commandFilePath of commandFilePaths) {
      const modulePath = toFileURL(commandFilePath);
      let importedObj = await import(`${modulePath}?t=${Date.now()}`);
      let commandObj = clone(importedObj);
      if (typeof module !== "undefined" && typeof require !== "undefined") {
        delete require.cache[require.resolve(commandFilePath)];
      }
      const compactFilePath = commandFilePath.split(process.cwd())[1] || commandFilePath;
      if (commandObj.default)
        commandObj = commandObj.default;
      if (importedObj.default) {
        commandObj.data = importedObj.default.data;
      } else {
        commandObj.data = importedObj.data;
      }
      if (!commandObj.data) {
        console.log(
          colors_default.yellow(
            `\u23E9 Ignoring: Command ${compactFilePath} does not export "data".`
          )
        );
        continue;
      }
      if (!commandObj.data.name) {
        console.log(
          colors_default.yellow(
            `\u23E9 Ignoring: Command ${compactFilePath} does not export "data.name".`
          )
        );
        continue;
      }
      if (!commandObj.run) {
        console.log(
          colors_default.yellow(
            `\u23E9 Ignoring: Command ${commandObj.data.name} does not export "run".`
          )
        );
        continue;
      }
      if (typeof commandObj.run !== "function") {
        console.log(
          colors_default.yellow(
            `\u23E9 Ignoring: Command ${commandObj.data.name} does not export "run" as a function.`
          )
        );
        continue;
      }
      commandObj.filePath = commandFilePath;
      let commandCategory = commandFilePath.split(this.#data.commandsPath)[1]?.replace(/\\\\|\\/g, "/").split("/")[1] || null;
      if (commandCategory && allowedExtensions.test(commandCategory)) {
        commandObj.category = null;
      } else {
        commandObj.category = commandCategory;
      }
      this.#data.commands.push(commandObj);
    }
  }
  #buildValidations() {
    for (const validationFunction of validations_default) {
      this.#data.builtInValidations.push(validationFunction);
    }
  }
  handleCommands() {
    this.#data.client.on("interactionCreate", async (interaction) => {
      if (!interaction.isChatInputCommand() && !interaction.isContextMenuCommand())
        return;
      const targetCommand = this.#data.commands.find(
        (cmd) => cmd.data.name === interaction.commandName
      );
      if (!targetCommand)
        return;
      const { data, options, run, ...rest } = targetCommand;
      const commandObj = {
        data: targetCommand.data,
        options: targetCommand.options,
        ...rest
      };
      if (this.#data.validationHandler) {
        let canRun2 = true;
        for (const validationFunction of this.#data.validationHandler.validations) {
          const stopValidationLoop = await validationFunction({
            interaction,
            commandObj,
            client: this.#data.client,
            handler: this.#data.commandkitInstance
          });
          if (stopValidationLoop) {
            canRun2 = false;
            break;
          }
        }
        if (!canRun2)
          return;
      }
      let canRun = true;
      if (!this.#data.skipBuiltInValidations) {
        for (const validation of this.#data.builtInValidations) {
          const stopValidationLoop = validation({
            targetCommand,
            interaction,
            handlerData: this.#data
          });
          if (stopValidationLoop) {
            canRun = false;
            break;
          }
        }
      }
      if (!canRun)
        return;
      targetCommand.run({
        interaction,
        client: this.#data.client,
        handler: this.#data.commandkitInstance
      });
    });
  }
  get commands() {
    return this.#data.commands;
  }
  async reloadCommands(type) {
    this.#data.commands = [];
    await this.#buildCommands();
    if (this.#data.bulkRegister) {
      await loadCommandsWithRest({
        client: this.#data.client,
        devGuildIds: this.#data.devGuildIds,
        commands: this.#data.commands,
        reloading: true,
        type
      });
    } else {
      await registerCommands({
        client: this.#data.client,
        devGuildIds: this.#data.devGuildIds,
        commands: this.#data.commands,
        reloading: true,
        type
      });
    }
  }
  async useUpdatedValidations() {
  }
};

// src/handlers/event-handler/EventHandler.ts
var import_rfdc2 = __toESM(require("rfdc"));
var clone2 = (0, import_rfdc2.default)();
var EventHandler = class {
  #data;
  constructor({ ...options }) {
    this.#data = {
      ...options,
      events: []
    };
  }
  async init() {
    await this.#buildEvents();
    this.#registerEvents();
  }
  async #buildEvents() {
    const eventFolderPaths = getFolderPaths(this.#data.eventsPath);
    for (const eventFolderPath of eventFolderPaths) {
      const eventName = eventFolderPath.replace(/\\\\|\\/g, "/").split("/").pop();
      const allowedExtensions = /\.(js|mjs|cjs|ts)$/i;
      const eventFilePaths = getFilePaths(eventFolderPath, true).filter(
        (path3) => allowedExtensions.test(path3)
      );
      const eventObj = {
        name: eventName,
        functions: []
      };
      this.#data.events.push(eventObj);
      for (const eventFilePath of eventFilePaths) {
        const modulePath = toFileURL(eventFilePath);
        let importedFunction = (await import(`${modulePath}?t=${Date.now()}`)).default;
        let eventFunction = clone2(importedFunction);
        if (typeof module !== "undefined" && typeof require !== "undefined") {
          delete require.cache[require.resolve(eventFilePath)];
        }
        if (eventFunction?.default) {
          eventFunction = eventFunction.default;
        }
        const compactFilePath = eventFilePath.split(process.cwd())[1] || eventFilePath;
        if (typeof eventFunction !== "function") {
          console.log(
            colors_default.yellow(
              `\u23E9 Ignoring: Event ${compactFilePath} does not export a function.`
            )
          );
          continue;
        }
        eventObj.functions.push(eventFunction);
      }
    }
  }
  #registerEvents() {
    const client = this.#data.client;
    const handler = this.#data.commandKitInstance;
    for (const eventObj of this.#data.events) {
      client.on(eventObj.name, async (...params) => {
        for (const eventFunction of eventObj.functions) {
          const stopEventLoop = await eventFunction(...params, client, handler);
          if (stopEventLoop) {
            break;
          }
        }
      });
    }
  }
  get events() {
    return this.#data.events;
  }
  async reloadEvents(commandHandler) {
    this.#data.events = [];
    await this.#buildEvents();
    this.#data.client.removeAllListeners();
    this.#registerEvents();
    commandHandler?.handleCommands();
  }
};

// src/handlers/validation-handler/ValidationHandler.ts
var import_rfdc3 = __toESM(require("rfdc"));
var clone3 = (0, import_rfdc3.default)();
var ValidationHandler = class {
  #data;
  constructor({ ...options }) {
    this.#data = {
      ...options,
      validations: []
    };
  }
  async init() {
    await this.#buildValidations();
  }
  async #buildValidations() {
    const allowedExtensions = /\.(js|mjs|cjs|ts)$/i;
    const validationFilePaths = getFilePaths(this.#data.validationsPath, true).filter(
      (path3) => allowedExtensions.test(path3)
    );
    for (const validationFilePath of validationFilePaths) {
      const modulePath = toFileURL(validationFilePath);
      let importedFunction = (await import(`${modulePath}?t=${Date.now()}`)).default;
      let validationFunction = clone3(importedFunction);
      if (typeof module !== "undefined" && typeof require !== "undefined") {
        delete require.cache[require.resolve(validationFilePath)];
      }
      if (validationFunction?.default) {
        validationFunction = validationFunction.default;
      }
      const compactFilePath = validationFilePath.split(process.cwd())[1] || validationFilePath;
      if (typeof validationFunction !== "function") {
        console.log(
          colors_default.yellow(
            `\u23E9 Ignoring: Validation ${compactFilePath} does not export a function.`
          )
        );
        continue;
      }
      this.#data.validations.push(validationFunction);
    }
  }
  get validations() {
    return this.#data.validations;
  }
  async reloadValidations() {
    this.#data.validations = [];
    await this.#buildValidations();
  }
};

// src/CommandKit.ts
var CommandKit = class {
  #data;
  constructor(options) {
    if (!options.client) {
      throw new Error(colors_default.red('"client" is required when instantiating CommandKit.'));
    }
    if (options.validationsPath && !options.commandsPath) {
      throw new Error(
        colors_default.red('"commandsPath" is required when "validationsPath" is set.')
      );
    }
    this.#data = options;
    this.#init();
  }
  async #init() {
    if (this.#data.eventsPath) {
      const eventHandler = new EventHandler({
        client: this.#data.client,
        eventsPath: this.#data.eventsPath,
        commandKitInstance: this
      });
      await eventHandler.init();
      this.#data.eventHandler = eventHandler;
    }
    if (this.#data.validationsPath) {
      const validationHandler = new ValidationHandler({
        validationsPath: this.#data.validationsPath
      });
      await validationHandler.init();
      this.#data.validationHandler = validationHandler;
    }
    if (this.#data.commandsPath) {
      const commandHandler = new CommandHandler({
        client: this.#data.client,
        commandsPath: this.#data.commandsPath,
        devGuildIds: this.#data.devGuildIds || [],
        devUserIds: this.#data.devUserIds || [],
        devRoleIds: this.#data.devRoleIds || [],
        validationHandler: this.#data.validationHandler,
        skipBuiltInValidations: this.#data.skipBuiltInValidations || false,
        commandkitInstance: this,
        bulkRegister: this.#data.bulkRegister || false
      });
      await commandHandler.init();
      this.#data.commandHandler = commandHandler;
    }
  }
  /**
   * Updates application commands with the latest from "commandsPath".
   */
  async reloadCommands(type) {
    if (!this.#data.commandHandler)
      return;
    await this.#data.commandHandler.reloadCommands(type);
  }
  /**
   * Updates application events with the latest from "eventsPath".
   */
  async reloadEvents() {
    if (!this.#data.eventHandler)
      return;
    await this.#data.eventHandler.reloadEvents(this.#data.commandHandler);
  }
  /**
   * Updates application command validations with the latest from "validationsPath".
   */
  async reloadValidations() {
    if (!this.#data.validationHandler)
      return;
    await this.#data.validationHandler.reloadValidations();
  }
  /**
   * @returns An array of objects of all the commands that CommandKit is handling.
   */
  get commands() {
    if (!this.#data.commandHandler) {
      return [];
    }
    const commands = this.#data.commandHandler.commands.map((cmd) => {
      const { run, ...command } = cmd;
      return command;
    });
    return commands;
  }
  /**
   * @returns The path to the commands folder which was set when instantiating CommandKit.
   */
  get commandsPath() {
    return this.#data.commandsPath;
  }
  /**
   * @returns The path to the events folder which was set when instantiating CommandKit.
   */
  get eventsPath() {
    return this.#data.eventsPath;
  }
  /**
   * @returns The path to the validations folder which was set when instantiating CommandKit.
   */
  get validationsPath() {
    return this.#data.validationsPath;
  }
  /**
   * @returns An array of all the developer user IDs which was set when instantiating CommandKit.
   */
  get devUserIds() {
    return this.#data.devUserIds || [];
  }
  /**
   * @returns An array of all the developer guild IDs which was set when instantiating CommandKit.
   */
  get devGuildIds() {
    return this.#data.devGuildIds || [];
  }
  /**
   * @returns An array of all the developer role IDs which was set when instantiating CommandKit.
   */
  get devRoleIds() {
    return this.#data.devRoleIds || [];
  }
};

// src/types/index.ts
var CommandType = /* @__PURE__ */ ((CommandType2) => {
  CommandType2[CommandType2["ChatInput"] = 1] = "ChatInput";
  CommandType2[CommandType2["Message"] = 3] = "Message";
  CommandType2[CommandType2["User"] = 2] = "User";
  return CommandType2;
})(CommandType || {});
var ReloadType = /* @__PURE__ */ ((ReloadType2) => {
  ReloadType2["Developer"] = "dev";
  ReloadType2["Global"] = "global";
  return ReloadType2;
})(ReloadType || {});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CommandKit,
  CommandType,
  ReloadType
});
